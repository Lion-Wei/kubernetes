## effective go学习及golang其他问题衍生

### Go routine实现



### Go channel

##### 一些疑问

channel关闭两次

- 会panic

往已经关闭的channel中写数据

- panic

从已关闭的channel中读数据

- 无缓冲区：不会panic，读到的是channel对象的初值
- 有缓冲区：可以继续读取数据，直到读完，读完按照第一条处理。
- 可以按照类似map[key]的形式判断当前channel是否已关闭
- 如果不判断是否已经读完了，则会一直执行第一条。



### 反射

##### 基本概念

实现三种功能（3定律）

1. 通过接口获取接口原来的对象
2. 通过对象获取它实现的接口
3. 修改被反射的对象（只有当传入对象的值是可设置的，才能修改）





## Map

hash，使用拉链法解决哈希碰撞问题，基本概念

- **装载因子**：数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加
- **溢出桶**：为了解决频繁扩容问题的设计，

#### 基本数据结构

- hmap：Map的数据结构，主要包含count/B/buckets/oldbuckets/extra字段
- bmap：bucket的实际承载结构，一个bucket最多包含8个键值对，多的放到溢出桶里面。
- extra：溢出桶，在内存空间上在bmap之后，用于减少扩容的频率

#### 操作

##### 扩容

触发条件：

- 装载因子超过6.5

- 溢出桶使用过多：等量扩容

  频繁的大量创建删除，可能最终容量还够，但是由于创建时使用了溢出桶，又没有溢出桶的回收机制的话，导致这部分溢出桶一直存在，可能引发内存泄露。

关注点：

1. 有保护机制，由于不是原子的过程，扩容时需判断当前是不是已经处在扩容状态，避免二次扩容的混乱。
2. 有oldbuckets和oldoverflow，在扩容过程中保存老的桶和溢出桶
3. 扩容过程大概是
   1. 创建新的bucket，老的bucket存到obdbuckets
   2. 对老桶的数据再分配，由于老桶肯定是有拉链在了，需要把老桶的东西分到新的两个桶里面，即分流。
   3. 扩容期间，map的读写操作都是在旧桶上操作，并且触发旧桶的内容复制到新的桶内。
   4. 扩容不是在需要扩容的时候一波扩玩，而是创建了之后在有写或者删除操作的时候才执行某个的扩容，这样防止瞬间性能的抖动。

##### 读写设计

- 使用hash函数和种子对key作hash
- hash后，用低位找到对应的桶号（这个根据当前桶数量具体看）
- 高8位用来作为tophash，用于与当前桶中的tophash作比较，加速查找（显然比较8位比比较key值快得多）
- 每个桶中最多放8个数据，多出来的放到溢出桶里



## Sync包及使用

`sync`包提供了并发编程中相关的一些基础能力，相当于一种同步机制。提供的基本能力包括：

- Mutex：锁
- RWMutex：读写锁
- WaitGroup：等待多个协程执行结束
- Once：全局执行一次
- Cond：condition的缩写。

#### WaitGroup

主要包含`Add\Done\Wait`，使用方法就是先`Add`，表示要执行多少个（初始化计数器）

`Done`就是调`Add(-1)`，计数器=0时，wait返回结果。表示执行结束

#### Mutex

Mutex即golang中的lock，是`Sync`包中最基本的部分，也是比较复杂的部分，主要就是实现了一个锁。而读写锁、Cond、Once，都是基于它实现的。

##### 几个概念

- **饥饿状态**：golang锁中有饥饿状态的概念，表示有协成等待了1ms以上。
  - 本质上是为了解决自旋可能带来的协成饿死的问题
- **自旋**：想要拿锁，发现锁位已经置1的情况下，就cpu空跑一小段时间（**30次pause**），再尝试拿锁；这里相当于sleep了一小会儿，但是它没有协成切换，没有转入阻塞；也就不会有协成切换的开销。
  - 因为自旋其实比较占cpu，所以进入自旋条件也比较苛刻，golang中自旋条件：
    - cpu数大于1
    - 等待调度队列为空
    - 调度机制允许多个process（GPM机制）
    - 自旋次数最多4次，超过就进入阻塞状态

##### 锁的状态标记

- **lock:** 32，锁定状态标记
- **Woken：**31，唤醒中？
- **Starving：** 30，饥饿状态
- **waitersCount：**0-29，等待队列数

##### lock和unlock

lock&自旋

1. 判断当前能否进入自旋，即lock&！starving
2. 进入自旋，等待释放
3. 计算锁的新的状态
4. 更新锁状态并获取锁

lock&非自旋

1. 进入队列，等待
2. 锁释放后，唤醒一个等待的协成

##### 自旋进入和退出

- 如果goroutine等待时间超过1ms，切换饥饿模式
- 如果到队列中最后一个goroutine，或者当前goroutine等待时间小于1ms，从饥饿模式退出



#### 参考

[同步原语与锁](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex)

[golang互斥锁实现剖析](https://my.oschina.net/renhc/blog/2876211)

[图解golang读写锁](https://juejin.im/post/6844904024748064781)









